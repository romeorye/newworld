<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="devon-rui-sample" content="yes" />
    <meta name="devon-rui-keyword" content="스크롤러(LScroller)" />
    <title>Scroller</title>

    <script type="text/javascript" src="./../../../js/rui_base.js"></script>
    <script type="text/javascript" src="./../../../js/rui_core.js"></script>
    <script type="text/javascript" src="./../../../js/rui_ui.js"></script>
    <script type="text/javascript" src="./../../../js/rui_form.js"></script>
    <script type="text/javascript" src="./../../../js/rui_grid.js"></script>
    <script type="text/javascript" src="./../../../resources/rui_config.js"></script>
    <link rel="stylesheet" type="text/css" href="./../../../resources/rui.css" />
    
    <script type="text/javascript" src="./../../../sample/general/rui_sample.js"></script>

    <style type="text/css">
    .LblockMarkupCode {
        height: 330px;
    }
    </style>

    <script type="text/javascript" class="script-code">
        Rui.onReady(function() {

            /*******************
             * 변수 및 객체 선언
             *******************/
            /*<b>*/
            var scroller = new Rui.ui.LScroller({
                content: 'contentDiv',
                marginSafe: true,
                //useVirtual: true,
                width: 500,
                height: 300
            });
            scroller.render('scrollDiv');
            /*</b>*/

            /********************
             * 버튼 선언 및 이벤트
             ********************/
            var moveBtn = new Rui.ui.LButton('moveBtn');
            moveBtn.on('click', function(){
                scroller.setScrollTop(scroller.getMaxScrollTop(100));
                Rui.log(scroller.getMaxScrollLeft());
                scroller.setScrollLeft(scroller.getMaxScrollLeft(40));
            });
            
            var resizeBtn = new Rui.ui.LButton('resizeBtn');
            resizeBtn.on('click', function(){
                if(scroller.getWidth() == 800)
                    scroller.setWidth(500);
                else
                    scroller.setWidth(800);
            });
            
            var useVirtualBtn = new Rui.ui.LButton('useVirtualBtn');
            useVirtualBtn.on('click', function(){
                   scroller.setupVirtualContent();
            });
            
        });
    </script>
</head>
<body>
    <div id='hd'>
        <h1>Scroller</h1>
        <div class="LblockLine"></div>
        <div class="LblockSubj">
            <h2>대량의 데이터를 LScroller를 이용하여 스크롤 할 수 있는 샘플</h2>
            <div class="LblockDesc">
                <p>LScroller를 이용하여 대량의 데이터를 제한된 영역 안에서 표현 할 수 있으며, 원하는 위치로 스크롤을 이동하여 컨텐츠를 보여줄 수 있다.</p>
            </div>
        </div>
    </div>
    <div id='bd'>
        <div class="LblockMarkupCode">
            <div id="scrollDiv">
                <div id="contentDiv" style="width:900px;margin:50px 20px">
                    스마트폰이 산업과 사회의 여러 분야에 커다란 영향을 미침에 따라 정말 해묵은 논쟁인 소위 ‘한국적 공인인증서 시스템’이 다시 도마에 오르고 있다. 스마트폰은 기종에 따라 탑재된 운영체제가 다른데 한국적 공인인증서 시스템의 적용이 어렵거나 불가능하다. 이는 스마트폰뿐만 아니라 향후에 선보일 각종 디지털 기기에서도 재연될 문제이다.
                    <br/>
                    여기서 필자가 말하는 한국적 공인인증서 시스템이란 한국에서 인터넷뱅킹이나 인터넷쇼핑을 할 때, 즉 전자금융거래를 할 때 모든 이용자들이 의무적으로 이용해야 하는 시스템을 뜻한다. 한국의 PC 이용자들은 오로지 인터넷 익스플로러(IE)만을 이용해야 하고 인증서 관리, 방화벽, 백신, 키보드보안 등을 위한 여러 개의 액티브엑스(ActiveX) 컨트롤을 설치해야만 전자금융거래를 할 수 있다. 
                    <br/>
                    전문가나 파워 유저를 제외한 대부분의 일반인들은 이러한 한국적 공인인증서 시스템이 상당히 불편하고 뭔가 이상하게 생각되면서도 문제의 본질을 정확히 파악하기 힘들고 또한 다른 방식을 아예 경험해 본 적이 없기에 그냥 수용하고 있는 형편이다.
                    <br/>
                    그렇다면 해외 여러 국가의 이용자들은 과연 어떤 환경에서 전자금융거래를 이용하고 있을까? 최근 금융보안연구원이 작성한 ‘해외 인터넷뱅킹 보안현황 조사 보고서’를 보면, 공인인증서 자체를 이용하는 국가가 거의 없을 뿐만 아니라, 오로지 하나의 웹브라우저를 국가에서 지정하고 더군다나 마이크로소프트마저 보안의 취약성 때문에 사용을 권고하지 않는 액티브엑스 기술을 반드시 이용하여 전자금융거래를 하도록 강제한 국가는 전무한 실정이다(보고서 전문은 필자의 블로그에서 다운로드 받을 수 있다). 
                    <br/>
                    대부분의 국가에서는 보안 시스템을 민간 업체가 자유롭게 선택할 수 있고 그에 따라 이용자의 웹브라우저 선택의 자유를 침해하지 않으며 업체들은 웹표준을 따라 웹브라우저에 기본 내장된 데이터 암호화 기술인 SSL(Secure Socket Layer), 그리고 일회용 비밀번호를 이용하는 기법인 OTP(One Time Password) 등 각종 기술을 통해 전자금융거래를 제공하고 있다. 참고로 OTP는 현존하는 보안 기법 중 가장 안전한 방식 중의 하나로서 SMS OTP, 토큰 OTP, 카드 OTP, 스마트카드 리더기 OTP 등 다양한 형태가 존재한다. 
                    <br/>
                    이와 같이 업체가 자율적으로 이용자의 편의성과 거래의 중요성을 따져 적절한 수위의 보안 기술을 조합하여 적용하는 방식이 일반적인 추세이다. 웹브라우저에 추가적인 플러그인 설치를 전혀 하지 않으면서 웹표준을 따르는 해외의 전자금융거래 방식은 현 시점에서 볼 때 한국적 공인인증서 시스템보다 더 안전하거나 최소한 덜 안전하지는 않다고 볼 수 있다. 
                    <br/>
                    왜냐하면 한국적 공인인증서 시스템은 취약한 액티브엑스 기술을 이용하고 있고 공인인증서를 보관하는 장소도 안전하지 않으며 그런 본질적인 문제점으로 인해서 효과가 떨어지는 여러 군더더기 기술들을 조합하여 사용하고 있기 때문이다. 예컨대, 해당 사이트에 들어갈 때만 동작하는 방화벽, 백신, 키보드보안 등의 액티브엑스 기반 프로그램은 보안성도 떨어지면서 이용자의 편의성만 저해한다. 
                    <br/>
                    물론 한국만의 이런 독특한 전자금융거래 방식을 무조건 비난할 수만은 없다. 그렇게 된 역사가 있기 때문이다. 10년 전 해당 기술을 도입할 당시에는 웹브라우저의 보안 기능이 미비했고 전자금융거래의 안전성을 보장할 수 있는 관련 기술도 부족했다. 또한 참고할만한 선진 사례도 별로 없었다. 
                    <br/>
                    그래서 한국만의 독자적인 보안 방식을 수립하고 정책적으로 강제함으로써 지금에 이르게 된 것이다. 이용자들의 편의성이 희생된 측면이 크고 부작용도 있었지만, 어쩔 수 없었던 도입 시점에서의 고민과 그간의 긍정적인 역할도 일부 인정해야 할 것이다. 
                    <br/>
                    하지만 이제는 아니다. 시대가 바뀌면 정책도 바뀌어야 한다. 해당 방식이 워낙 근본적인 취약성을 안고 있다 보니 인증서가 대량으로 유출되는 사건도 발생하고 있고, 이에 따라 최근 정부기관에서는 PC 하드디스크에 아예 공인인증서를 저장하지 못하게 하고 USB 등의 저장장치만을 이용하게 하겠다는 방침을 밝히기도 했다. 
                    <br/>
                    씁쓸한 일이다. 실효성이 별로 없는 공인인증서를, 안전하지 않은 방식으로 이용함으로써 발생하는 근본적인 문제점을 막기 위해 계속 땜질이 행해지고 있는 것이다. 스마트폰에서도 기존의 한국적 공인인증서 시스템을 최대한 적용하기 위하여 그다지 보안성도 없으면서 이용자들의 편의성만 희생하는 각종 편법이 논의되고 있는 상황이다. 
                    <br/>
                    우리가 보안과 관련된 손익을 계산할 때 단지 보안을 위해 투입되는 비용과 보안에 문제가 생겼을 때 발생하는 손실만을 따져서는 안 된다. 보안은 오버헤드를 발생시킨다. 그러므로 보안 시스템이 영향을 미치는 모든 요소들을 따져보아야 한다. 현재의 한국적 공인인증서 시스템은 그 보안성조차 의심스러운 상태에서 이용자들의 편의성을 희생하고 또한 미래 산업의 성장까지 가로막고 있다고 볼 수 있다. 
                    <br/>
                    이 문제와 관련하여 우리는 다음과 같은 세 가지 안 중에서 하나를 선택할 수 있다. 
                    <br/>
                    A안, 기존의 한국적 공인인증서 시스템을 과감히 폐기하고 새로운 보안 체계를 수립하는 것이다. 거듭 말하지만 한국적 공인인증서 시스템은 이제 그 생명이 다했다. 사용된 기술도 그렇거니와 현 시대와 다가올 미래의 다양한 요구를 충족시킬 수 있는 상황도 아니다. 
                    <br/>
                    이미 PC와 스마트폰에서는 별도의 플러그인 설치 없이 웹표준을 준수하며 이용할 수 있는 여러 기술들이 존재한다. 눈을 뜨고 편견 없이 관련 기술들을 검토하고 선택하면 된다. 보다 나은 대안이 분명히 존재하고 있으니까 말이다. 
                    <br/>
                    B안, 앞서 말한 A안이 당장 불가능하다면 적어도 선택적으로 웹표준을 따르는 보안 기술을 이용할 수 있도록 하는 것이다. 선택의 폭을 넓혀 주는 것이다. 정부가 정한 단 하나의 전자금융거래 방식만을 강요하는 건 해외에서는 상상할 수도 없는 일이다. 규제 남용이다. 
                    <br/>
                    그렇지만 이해관계의 복잡성 등 피치 못할 이유 때문에 한국적 공인인증서 시스템을 당장 폐기할 수 없다면, 적어도 웹표준을 준수하는 보안 기술을 민간이 선택적으로 이용할 수 있는 길을 열어 놓자. 최소한 이 정도라도 하는 게 합리적이지 않은가? 전세계 모든 나라들이 하는 걸 한국이 못할 게 무언가? 
                    <br/>
                    C안, 만일 우리가 A안 또는 B안 중 어느 하나를 선택하지 않는다면 자동으로 C안이 된다. 바로 한국적 공인인증서 시스템을 앞으로도 영원히 유지하는 것이다. 10년 전 당시에는 나름 최선의 방법이었기에 선택했더라도, 이제는 낡고 병든 이 방식을 영원히 유지하는 것 말이다. 
                    <br/>
                    이용자들의 웹브라우저 선택권을 빼앗고(사실은 운영체제 선택권도 빼앗는 것이다), 마이크로소프트조차 사용하지 말라는 액티브엑스 방식을 이용하면서(이 이유 하나만으로도 사실상 폐기 대상이다), 강제적으로 방화벽/백신/키보드보안 등 각종 플러그인을 설치하고(그렇다고 제대로 보안이 되는 것도 아니다), 이런 방식을 스마트폰에도 그대로 적용하기 위해 각종 편법을 동원하고(정말 억지로 짜맞춘 느낌이다), 국민들의 편의성을 심각하게 희생하고(정부는 이와 관련된 비용을 계산해보아야 한다), 관련 산업의 활성화도 가로 막는 게 바로 C안이다. 
                    <br/>
                    다시 한번 말하지만, 시대가 바뀌면 정책도 바뀌어야 한다. 과거에 해당 정책이 의미가 있었다고 하더라도, 시대가 바뀌고 환경이 바뀌었다면 정책도 바뀌어야 한다. 이 이슈에 대해 현재 관련 정부기관들(행안부, 금융위, 인터넷진흥원)은 전세계에서 한국이 인터넷 일등 국가이기 때문에 해외 선진국들의 사례를 우리가 따라야 할 필요가 없다는 논리를 제시하고 있다. 
                    <br/>
                    하지만 그것은 사실이 아니다. 10년 전에는 우리가 그들보다 앞서 있었지만, 지금은 아니다. 한국의 인터넷 산업은 수년째 정체되어 근래 해외에서 등장한 다양한 인터넷 서비스 모델들을 한국에서는 거의 찾아보기도 힘들며, 게임 등 일부를 제외하곤 모바일 서비스/콘텐츠 분야는 거의 후진국에 가깝다. 
                    <br/>
                    오해가 없길 바란다. 필자의 이런 주장이 보안성을 희생하자는 건 아니다. 충분한 보안성을 달성하면서도 국민들을 불편하게 하지 않고 관련 산업도 활성화할 수 있는 방법이 있는데, 왜 과거의 낡은 방식에 집착하여 우리의 현재와 미래를 희생하는가를 묻고 있는 것이다. 미래 산업의 경쟁력 확보와 국민의 편의성 증진을 위해 변화를 위한 결단을 더 이상 지체해서는 안 된다. 이 문제에 대한 독자 여러분의 관심과 호응을 기대한다. @
                </div>
            </div>
        </div>
        <div class="LblockButton" >
            <button type="button" id="moveBtn" >스크롤 위치이동</button>
            <button type="button" id="resizeBtn" >스크롤러 크기 변경</button>
            <button type="button" id="useVirtualBtn" >가상 스크롤 사용</button>
        </div>
    </div>
</body>
</html>